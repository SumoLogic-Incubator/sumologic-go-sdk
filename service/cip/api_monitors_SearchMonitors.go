package cip

import (
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/SumoLogic-Labs/sumologic-go-sdk/service/cip/types"
)

/*
SearchMonitors
Search for a monitor or folder in the monitors library structure.

	query - The search query to find monitor or folder. The following is a list of different filters:
		**createdBy**: Filter by the user's identifier who created the content (createdBy:000000000000968B).
		**createdBefore**: Filter by the content objects created before the given timestamp(in milliseconds) (createdBefore:1457997222).
		**createdAfter**: Filter by the content objects created after the given timestamp(in milliseconds) (createdAfter:1457997111).
		**modifiedBefore**: Filter by the content objects modified before the given timestamp(in milliseconds) (modifiedBefore:1457997222).
		**modifiedAfter**:  Filter by the content objects modified after the given timestamp(in milliseconds) (modifiedAfter:1457997111).
		**type**: Filter by the type of the content object (type:folder).
		**monitorStatus**: Filter by the status of the monitor: Normal, Critical, Warning, MissingData, Disabled, AllTriggered (monitorStatus:Normal).
		You can also use multiple filters in one query. For example to search for all content objects created by user with identifier 000000000000968B with creation timestamp after 1457997222 containing the text Test, the query would look like:
	optional - nil or *types.MonitorsSearchOpts - Optional Parameters:
		Limit (optional.Int32) - Maximum number of items you want in the response.
		Offset (optional.Int32) - The position or row from where to start the search operation.
*/
func (a *APIClient) SearchMonitors(query string, localVarOptionals *types.MonitorsSearchOpts) ([]types.MonitorsLibraryItemWithPath, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []types.MonitorsLibraryItemWithPath
	)

	// create path and map variables
	localVarPath := a.Cfg.BasePath + "/v1/monitors/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.prepareRequest(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	} else if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []types.MonitorsLibraryItemWithPath
			err = a.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		} else if localVarHttpResponse.StatusCode >= 400 {
			var v types.ErrorResponse
			err = a.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			if len(v.Errors) > 0 {
				if v.Errors[0].Meta.Reason != "" {
					newErr.error = v.Errors[0].Message + ": " + v.Errors[0].Meta.Reason
				} else {
					newErr.error = v.Errors[0].Message
				}
			}
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
